<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.94.1" />


<link rel="apple-touch-icon" sizes="180x180" href="/siteimage/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/siteimage/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/siteimage/favicon-16x16.png">
<link rel="manifest" href="/siteimage/manifest.json">
<link rel="mask-icon" href="/siteimage/safari-pinned-tab.svg" color="#5bbad5">


<title>十七章 進階上色 - AngusChan&#39;s Devlog</title>


<meta name="author" content="AngusChan" />


<meta name="description" content="AngusChan&#39;s website" />



<meta property="og:title" content="十七章 進階上色" />
<meta name="twitter:title" content="十七章 進階上色" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://angus945.github.io/learn/shader-sdf-animation/17-furthercoloring/" /><meta property="og:description" content="標準化空間，大小為 10 進階上色 目前為止的距離場圖形只有用到兩種顏色，距離場內和距離場外，不過我們還可以使用更多種顏色來繪製距離場圖形。 組合上色 首先我們可以讓不同距離場有各自的顏色，例如紅色的矩形和綠色的" />
<meta name="twitter:description" content="標準化空間，大小為 10 進階上色 目前為止的距離場圖形只有用到兩種顏色，距離場內和距離場外，不過我們還可以使用更多種顏色來繪製距離場圖形。 組合上色 首先我們可以讓不同距離場有各自的顏色，例如紅色的矩形和綠色的" /><meta property="og:image" content="https://angus945.github.io/siteImage/head.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://angus945.github.io/siteImage/head.png" /><meta property="article:published_time" content="2021-07-28T10:20:32+08:00" /><meta property="article:modified_time" content="2021-07-28T10:20:32+08:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://angus945.github.io/assets/css/fuji.min.css" />






<script>
    window.ga_tid = 'G-LTVT6WYDT4';
    window.ga_api = '';
</script>
<script async src="https://cdn.jsdelivr.net/npm/cfga@1.0.3/cfga.min.js"></script>




<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>





<link rel="stylesheet" href="https://angus945.github.io/global-scrollbar.5b598faf3be22e0dd92d4c8d17451723ee2e6bb2a7d402d526e30ad977125fdb.css" integrity="sha256-W1mPrzviLg3ZLUyNF0UXI&#43;4ua7Kn1ALVJuMK2XcSX9s=">






<link rel="stylesheet" href="https://angus945.github.io/content-style.73e84ce876a003ab9119845f2f03a0c36a0c7160033ab908600bdb089b9025da.css" integrity="sha256-c&#43;hM6HagA6uRGYRfLwOgw2oMcWADOrkIYAvbCJuQJdo=">





<link rel="stylesheet" href="https://angus945.github.io/content-tag.915161822b6cfc6da80cf9d7f6ae8b68c37fb31b618c2b20498c085794c794fa.css" integrity="sha256-kVFhgits/G2oDPnX9q6LaMN/sxthjCsgSYwIV5THlPo=">









<link rel="stylesheet" href="https://angus945.github.io/shader-container.54a276cdb630bc8fd5752d641e77a5834b7d3d2b7284f5506104257a71ad81c1.css" integrity="sha256-VKJ2zbYwvI/VdS1kHnelg0t9PStyhPVQYQQlenGtgcE=">



<script type="text/javascript" src="https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js"></script>







<script type="text/javascript">

    
    window.addEventListener('load', function()
    {
        var containers = document.getElementsByClassName("shader-container");
        
        for(var i = 0; i < containers.length; i++)
        {
            loadShader(containers[i]);
        }
    });
    function loadShader(container)
    {
        var input = container.getElementsByClassName("shader-input")[0];
        
        if(input == null) return;
        
        var canvas = container.getElementsByTagName("canvas")[0];
        var sandbox = new GlslCanvas(canvas);

        var fields = container.getElementsByClassName("shader-input-field");
        var datas = JSON.parse(input.dataset.inputs);

        for(var i = 0; i < fields.length; i ++)
        {
            setInput(sandbox, fields[i], datas[i]);
        }
    };
    function setInput(sandbox, field, data)
    {
        switch(data.type)
        {
            case "int":
                rangeField(sandbox, field, data, 0);
                break;
                
            case "float":
                rangeField(sandbox, field, data, 2);
                break;
                
            case "vector":
                vectorField(sandbox, field, data);
                break;
        }
    }
    function rangeField(sandbox, field, data, fixed)
    {
        var value = field.querySelector("#value");
        var slider = field.getElementsByTagName("input")[0];

        slider.addEventListener('input', (event) => {
            var input = parseFloat(slider.value);

            sandbox.setUniform(data.name, input);
            value.innerHTML = input.toFixed(fixed);
        });

        value.innerHTML = parseFloat(slider.value).toFixed(fixed);
        sandbox.setUniform(data.name, parseFloat(slider.value));
    }

    function vectorField(sandbox, field, data)
    {            
        var value = field.querySelector("#value");
        value.innerHTML = data.default;
        
        var picker = field.getElementsByTagName("canvas")[0];
        picker.width = picker.clientWidth;
        picker.height = picker.clientHeight;
        picker.style.display = "none";

        var context = picker.getContext('2d');

        var minX = parseFloat(data.min.x);
        var maxX = parseFloat(data.max.x);
        var minY = parseFloat(data.min.y);
        var maxY = parseFloat(data.max.y);

        var popup = false;
        var mouseDown = false;
        
        value.addEventListener('click', (event) => {
            popup = !popup;
            picker.style.display = popup ? "block" : "none";
        });
        picker.addEventListener('mousedown', (event) => {
            mouseDown = true;

            pickPosition(event);
        });
        picker.addEventListener('mousemove', (event) => {

            if(!mouseDown) return;

            pickPosition(event);                
        });
        picker.addEventListener('mouseup', (event) => {
            mouseDown = false;
        });
                    
        function pickPosition(event)
        {
            var rect = picker.getBoundingClientRect();
            var clickX = event.pageX - picker.offsetLeft;
            var clickY = event.clientY - rect.top;
            
            var uvX = (clickX) / rect.width;
            var uvY = 1 - (clickY) / rect.height;

            var x = minX + (maxX - minX) * uvX;
            var y = minY + (maxY - minY) * uvY;

            drawPoint(picker, context, clickX, clickY, 'red', 5);
            value.innerHTML = `(${ x.toFixed(2) }, ${ y.toFixed(2) })`;
            
            sandbox.setUniform(data.name, x, y);              
        }
        function drawPoint(canvas, context, x, y, color, radius) 
        {
            context.clearRect(0, 0, canvas.width, canvas.height);

            context.fillStyle = "red"; 
            
            context.beginPath();
            context.arc(x, y, radius, 0, 2 * Math.PI, true);
            context.fill();
        }
    }
</script>








    
    
    
    
    
    
    
    
    



<script type="text/javascript">
    var seed = Math.random();
    var frag_codes = ("#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform vec2 u_resolution;\r\nuniform vec2 u_mouse;\r\nuniform float u_time;\r\n\r\nuniform float u_seed;\r\n\r\nuniform sampler2D u_buffer0;\r\n\r\n\r\n#ifdef BUFFER_0\r\n\r\nvec4 readBuffer(sampler2D buffer, vec2 coord)\r\n{\r\n    vec2 uv = gl_FragCoord.xy \/ u_resolution.xy;\r\n    return texture2D(buffer, uv, 0.0);\r\n}\r\n\r\nvoid main() \r\n{\r\n    float width = (u_resolution.x);\r\n    vec2 uv = gl_FragCoord.xy \/ width;\r\n    vec2 mouse = u_mouse.xy \/ width;\r\n\r\n    float value = readBuffer(u_buffer0, gl_FragCoord.xy).a;\r\n    float circle = 1. - ceil(length(uv - mouse) - .05);\r\n\r\n    value = value * 0.95;\r\n    value = max(value, circle);\r\n\r\n    value = clamp(value, 0.0, 1.0);\r\n    gl_FragColor = vec4(value);\r\n}\r\n\r\n#else\r\n\r\nvoid main() {\r\n    vec2 uv = gl_FragCoord.xy \/ u_resolution.xy;\r\n    vec4 color = texture2D(u_buffer0, uv, 0.0);\r\n\r\n    gl_FragColor = color;\r\n}\r\n\r\n#endif\u003cslice-identifier\u003e#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform vec2 u_resolution;\r\nuniform vec2 u_mouse;\r\nuniform float u_time;\r\n\r\nuniform float u_seed;\r\n\r\nuniform sampler2D u_buffer0;\r\n\r\nfloat random(vec2 st)\r\n{\r\n    return fract(sin(dot(st.xy, vec2(12.9898, u_seed))) * 43758.5453123);\r\n}\r\nvoid main()\r\n{\r\n    float width = min(u_resolution.x, u_resolution.y);\r\n    vec2 uv = gl_FragCoord.xy \/ width;\r\n\r\n    vec2 cell = fract(uv * 10.0);\r\n    vec2 coord = floor(uv * 10.0);\r\n\r\n    float value = random(coord.xy);\r\n    gl_FragColor = vec4(value, value, value, 1);\r\n    \/\/ gl_FragColor = vec4(cell, 0, 1);\r\n    \/\/ gl_FragColor = vec4(coord \/ 10.0, 0, 1);\r\n}\r\n\u003cslice-identifier\u003e").split("\u003cslice-identifier\u003e");
    var frag_shader_code = randomFragment();
  
    function randomFragment()
    {
        var max = frag_codes.length - 1;
        var rndIndex = Math.floor(Math.random() * max);
        var rndFragment = frag_codes[rndIndex];
    
        return rndFragment;
    }
    
    var canvas = document.createElement("canvas");
    canvas.classList.add("shader-background");
    
    function updateSize()
    {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
    }
    function updatePosition()
    {
        canvas.style.top = 0;
    }
    
    window.addEventListener('load', function () 
    {
        var sandbox = new GlslCanvas(canvas);
        
        sandbox.load(frag_shader_code);
        sandbox.setUniform("u_seed", seed);
        
        var main = document.getElementsByTagName("main")[0]; 
        main.appendChild(canvas);
        
        updateSize();
        updatePosition();
    });
    
    window.onresize = function()
    {
        updateSize();
        updatePosition();
    }

    
</script>




</head>

<body
  data-theme="dark"
  data-theme-auto='false'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://angus945.github.io/">AngusChan&#39;s Devlog</a>
            
            <span class="title-sub">subTitle</span>
            
        </div>
    </div>
</header>

    <main style="position: relative;">
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://angus945.github.io/learn/shader-sdf-animation/17-furthercoloring/">十七章 進階上色</a>
    </h2>
    <div class="post-item post-meta">
        <span>
    <i class="iconfont icon-today-sharp"></i> &nbsp;
    2021-07-28
</span>




<span>
    <i class="iconfont icon-file-tray-sharp"></i>&nbsp;2157 words
</span>




<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;No tag</span>

    </div>
    
    <div class="post-content markdown-body">
        
         
         

        <p>標準化空間，大小為 10</p>
<h2 id="進階上色">進階上色</h2>
<p>目前為止的距離場圖形只有用到兩種顏色，距離場內和距離場外，不過我們還可以使用更多種顏色來繪製距離場圖形。</p>
<h3 id="組合上色">組合上色</h3>
<p>首先我們可以讓不同距離場有各自的顏色，例如紅色的矩形和綠色的圓形，只需要判斷點是在哪個距離場中即可。回到一般的距離場計算，先繪製出兩個疊加圖形的距離。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float dA = SDF_Rect(uv, 2);
float dB = SDF_circle(translate(uv, 1), 2);
return combina_add(dA, dB);
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/combina_0.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/combina_0.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>複習一下組合疊加是怎麼計算的，我們透過取小值來合併兩個距離場形狀。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">return min(a, b);
</code></pre>
<p>因此，如果想讓形狀有各自顏色，只需要在判斷的時候也一併區分要繪製的像素顏色就好。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float Combina_color_add(float a, float b, fixed4 colA, fixed4 colB, out fixed4 col)
{
    if(a &lt; b)
    {
        col = colA;
        return a;
    }
    else    
    {
        col = colB;
        return b;
    }
}
</code></pre>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 colA = fixed4(1, 0, 0, 1);
fixed4 colB = fixed4(0, 1, 0, 1);

fixed4 color;
float distance = Combina_color_add(dA, dB, colA, colB, color);

distance = ceil(distance);
color = lerp(color, _BackgroundColor, saturate(distance));

return color;
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/combina_1.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/combina_1.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>可以看到，雖然形狀現在有各自的顏色，但是內部交界處的效果和想像的不同，主要是因為距離場內測的計算不太正確，但是在只有單色時這個問題不會影響結果。</p>
<p>這個問題沒辦法修復，因為內側的交界情況難以預測，所以組合上色通常會是在三維空間中繪製距離場時才使用的，因為三維中不會看到形狀內部的情況。</p>
<p>所以當我們要在二維中使用組合上色時，必須避免兩個發生交界的形狀使用不同顏色。</p>
<h3 id="覆蓋上色">覆蓋上色</h3>
<p>和上個上色方法的效果類似，只不過這次是直接將新顏色覆蓋上去，使用距離來插值新顏色和舊 (背景) 顏色就能達到覆蓋的效果。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 colorOverlap(fixed4 overlapColor, fixed4 baseColor, float distance)
{
    return lerp(overlapColor, baseColor, saturate(distance));
}
</code></pre>
<p>首先將顏色指定為背景，上色時使用形狀的距離一層一層覆蓋上去即可。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float dA = SDF_Rect(uv, 2);
float dB = SDF_circle(translate(uv, 1), 2);

fixed4 color = _BackgroundColor;
color = colorOverlap(fixed4(1, 0, 0, 1), color, ceil(dA));
color = colorOverlap(fixed4(0, 1, 0, 1), color, ceil(dB));
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/overlap.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/overlap.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>使用這種做法就不用擔心交界的問題了，唯一的限制只有順序會直接影像結果，後畫的形狀會蓋過先前的所有圖形。</p>
<h3 id="計算上色">計算上色</h3>
<p>在前面的章節有提到，我們能夠透過參數對距離場的任何計算進行操作，甚至是顏色也行。再次使用線段舉例，我們可以讓線的兩端在不同顏色間產生過度。</p>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/calculate_0.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/calculate_0.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>同樣使用投影的距離值作為讓色參考，首先讓原本的線段函數回傳投影值。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float SDF_line(float2 uv, float2 pointA, float2 pointB, float thickness,
    out float projToLine)
{
    float2 lineDirection = normalize(pointB - pointA);
    float lineLength = length(pointB - pointA);
    **projToLine = dot(uv - pointA, lineDirection);**

    float2 lineNormal = cross(float3(lineDirection.xy, 0), float3(0, 0, 1));
    float dist = lerp
        (
            length(uv - pointA), lerp(abs(dot(uv - pointA, lineNormal)), length(uv - pointB), 
            step(lineLength, projToLine)), step(0, projToLine)
        );           
    
    return dist - thickness;              
}
</code></pre>
<p>建立一個接收和回傳顏色的線段函數多載，並調用原本的函數取得距離和投影值，將投影的數值除以線段長度取得比例，並使用比例值當作插值的權重。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float SDF_Color_line(float2 uv, float2 pointA, float2 pointB, float thickness, 
    fixed4 colA, fixed4 colB, out fixed4 col)
{
    float projToLine;
    float distance = SDF_line(uv, pointA, pointB, thickness, projToLine);

    float lineLength = length(pointB - pointA);

    col = lerp(colA, colB, saturate(projToLine / lineLength));
    return distance;
}
</code></pre>
<p>最後調用上色的距離場函數繪製線段。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 colA = fixed4(1, 0, 0, 1);
fixed4 colB = fixed4(0, 1, 0, 1);

fixed4 color;
float distance = SDF_Color_line(uv, -5, 5, 1, colA, colB, color);
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/calculate_1.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/calculate_1.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>而當然和其他修改一樣，計算上色也不局限於線段，實際上可以將任何數值作為插值的權重，像是角度，以圓環為例將弧度作為顏色插值的權重。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float SDF_Color_Ring(float2 uv, float radius, float thickness, fixed4 colA, fixed4 colB, 
    out fixed4 col)
{
    float radian = abs(atan2(uv.y, uv.x));
    col = lerp(colA, colB, radian / PI);

    return SDF_Ring(uv, radius, thickness);
}
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/calculate_2.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/calculate_2.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<h3 id="噪聲上色">噪聲上色</h3>
<p>使用噪聲計算來替顏色進行微小修改，讓顏色不要那麼單調，不過噪聲的計算已經超出教學的範圍了，所以這裡提供簡單的噪聲算法做為參考。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float noise_random(float2 uv) 
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
}
</code></pre>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float noise_valueNoise(float2 uv)
{
    float2 i = floor(uv);
    float2 f = frac(uv);

    float a = noise_random(i);
    float b = noise_random(i + float2(1.0, 0.0));
    float c = noise_random(i + float2(0.0, 1.0));
    float d = noise_random(i + float2(1.0, 1.0));

    float2 u = f*f*(3.0-2.0*f);

    return lerp(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}
</code></pre>
<p>將計算結果作為顏色上的噪點。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 color = _ShapeColor * lerp(0.8, 1.2, noise_valueNoise(uv));
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/noise.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/noise.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>其實噪聲的數值範圍可以在小一點，這裡設 0.4 的範圍主要還是方便展示而已，實際上 0.1 ~ 0.2 就夠了，你們也可以換個顏色看看，向是棕色或灰色就會產生木質和金屬的質感。</p>
<h3 id="貼圖上色">貼圖上色</h3>
<p>除了單一的顏色以外，我們也可以使用紋理貼圖為距離場著色，而距離場的運算特性同樣也能輕易地做到。首先添加一項 texture 屬性給著色器，並自行放上喜歡的圖片。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">_SDFTexture (&quot;Texture&quot;, 2D) = &quot;white&quot; { }
sampler2D _SDFTexture;
</code></pre>
<p>再來是建立一像貼圖著色的距離場計算函式，輸入貼圖和形狀參數回傳顏色。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 Texture_SDF_Rect(float2 uv, float2 size, sampler2D tex)
{
    fixed4 color = tex2D(tex, uv);
    
    return color;
}
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/texture_0.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/texture_0.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>註 : 圖片拉長的原因是 texture clamp 造成的，不用擔心。</p>
<p>由於空間操作的關係，我們函數計算的 uv 輸入是經過縮放的，因此我們得先將圖片放大回原本的大小。</p>
<p>放大的部分很簡單，在開頭幾章的縮放操作中就有提到了，只需要除以大小即可，不過要注意矩形距離場輸入的大小為直徑，所以還得再次除以二才能將 uv 變回原本的大小。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 Texture_SDF_Rect(float2 uv, float2 size, sampler2D tex, fixed4 baseColor)
{
    float2 mappingUV = uv / size / 2;
    fixed4 color = tex2D(tex, mappingUV);
    
    return color;
}
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/texture_1.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/texture_1.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>現在大小正確了但位置不正確，因為 uv 是從空間中心的 (0, 0) 開始的，所以紋理的 uv 運算也會從空間正中心開始，我們得要將 uv 朝正確的方向偏移。</p>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/texture_2.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/texture_2.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>偏移的部分相信各位還沒忘，要往左下角偏移的話就用加的，只要加上形狀大小即可。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">float2 mappingUV = (uv + size) / size / 2;
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/texture_3.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/texture_3.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>接著只剩一步 - 完成距離場計算，我們的目的是透過貼圖為距離場著色，也代表只有距離場會使用到貼圖的顏色，其他部分都不需要。</p>
<p>如何剔除不需要的部分 ? 只要使用計算出的距離值就可以了，我們可以透過距離直當作上色的遮罩，將不需要的部分過濾掉，對貼圖顏色和背景顏色進行插值就能完成。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 Texture_SDF_Rect(float2 uv, float2 size, sampler2D tex, fixed4 baseColor)
{
    float distance = SDF_Rect(uv, size);
    distance = ceil(distance);

    float2 mappingUV = (uv + size) / size / 2;
    fixed4 color = tex2D(tex, mappingUV);
    
    return lerp(color, baseColor, saturate(distance));
}
</code></pre>







<div class="image" style="width: 50%;" >
    <img src="/learn/shader/sdf-animation/texture_4.jpg" alt="image display error, please report: [/learn/shader/sdf-animation/texture_4.jpg]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>大功告成，如此一來我們就能為距離場畫上貼圖了，並且直接和空間操作相容，如果想繪製不同圖形也只需要修改距離場算法即可。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">fixed4 Texture_SDF_Circle(float2 uv, float radius, sampler2D tex, fixed4 baseColor)
{
    float distance = SDF_circle(uv, radius);
    distance = ceil(distance);

    float2 mappingUV = (uv) / radius / 2;
    fixed4 color = tex2D(tex, mappingUV);
    
    return color;
}
</code></pre>







<div class="image" style="width: ;" >
    <img src="/learn/shader/sdf-animation/texture_5.gif" alt="image display error, please report: [/learn/shader/sdf-animation/texture_5.gif]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>雖然這樣就很不錯了，但其實可以再更進一步，目前的上色算法是每次計算距離場上色就會強制貼圖顏色蓋上去，因此當上色時遇到半透明貼圖，那他的透明度會沒有效果，所以我們可以將上色計算加入不透明運算，原理就不多解釋了。</p>
<pre><span>csharp</span><hr style='margin-top:5px; margin-bottom:0px'>
<code class="language-csharp">color = (color * color.a) + (baseColor * (1 - color.a));
</code></pre>







<div class="image" style="width: ;" >
    <img src="/learn/shader/sdf-animation/texture_6.gif" alt="image display error, please report: [/learn/shader/sdf-animation/texture_6.gif]">
    <p style="opacity: 0.5">
        
    </p>
</div>


<p>以上就是進階的距離場上色方法，只要搭配進階上色使用又能夠畫出更精緻的圖形了。</p>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>
            Unless otherwise noted, the content of this site is licensed under  
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a>
            .
        </p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/devlog/">Devlog</a>
            </li>
            
            <li>
                <a href="/learn/">Learn</a>
            </li>
            
            <li>
                <a href="/post/">Post</a>
            </li>
            
            <li>
                <a href="/about">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/angus945/" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://twitter.com/angus9456" target="_blank"><span>Twitter</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/computeshader/">ComputeShader</a>
            </span>
            
            <span>
                <a href="/tags/devlog/">devlog</a>
            </span>
            
            <span>
                <a href="/tags/learning/">learning</a>
            </span>
            
            <span>
                <a href="/tags/resources/">resources</a>
            </span>
            
            <span>
                <a href="/tags/shader/">shader</a>
            </span>
            
            <span>
                <a href="/tags/test/">test</a>
            </span>
            
            <span>
                <a href="/tags/unity/">unity</a>
            </span>
            
            <span>
                <a href="/tags/website/">website</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#進階上色">進階上色</a>
      <ul>
        <li><a href="#組合上色">組合上色</a></li>
        <li><a href="#覆蓋上色">覆蓋上色</a></li>
        <li><a href="#計算上色">計算上色</a></li>
        <li><a href="#噪聲上色">噪聲上色</a></li>
        <li><a href="#貼圖上色">貼圖上色</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/devlog/">Devlog</a>
            </li>
            
            <li>
                <a href="/learn/">Learn</a>
            </li>
            
            <li>
                <a href="/post/">Post</a>
            </li>
            
            <li>
                <a href="/about">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/angus945/" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://twitter.com/angus9456" target="_blank"><span>Twitter</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/computeshader/">ComputeShader</a>
            </span>
            
            <span>
                <a href="/tags/devlog/">devlog</a>
            </span>
            
            <span>
                <a href="/tags/learning/">learning</a>
            </span>
            
            <span>
                <a href="/tags/resources/">resources</a>
            </span>
            
            <span>
                <a href="/tags/shader/">shader</a>
            </span>
            
            <span>
                <a href="/tags/test/">test</a>
            </span>
            
            <span>
                <a href="/tags/unity/">unity</a>
            </span>
            
            <span>
                <a href="/tags/website/">website</a>
            </span>
            
        </div>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2021-2022
                <a href="https://angus945.github.io/">AngusChan</a>
                 | <a href="https://github.com/angus945/angus945.github.io">Source code</a> 
                | Powered by <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>



</body>

</html>
